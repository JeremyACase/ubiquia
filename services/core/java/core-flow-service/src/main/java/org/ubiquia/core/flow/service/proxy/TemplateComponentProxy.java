package org.ubiquia.core.flow.service.proxy;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.transaction.Transactional;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.Random;
import net.jimblackler.jsongenerator.DefaultConfig;
import net.jimblackler.jsongenerator.Generator;
import net.jimblackler.jsongenerator.JsonGeneratorException;
import net.jimblackler.jsonschemafriend.GenerationException;
import net.jimblackler.jsonschemafriend.Schema;
import net.jimblackler.jsonschemafriend.SchemaStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.ubiquia.common.model.ubiquia.entity.FlowEventEntity;
import org.ubiquia.core.flow.repository.NodeRepository;
import org.ubiquia.core.flow.service.io.Outbox;
import org.ubiquia.core.flow.service.visitor.StamperVisitor;

/**
 * This is a service within Ubiquia that can be used to generated "dummy data" within the
 * constraints of an agent's declared input and output schemas. When an agent
 * in an Ubiquia DAG is defined as a "template" agent, this service can be used to act
 * as a proxy for that agent.
 * This is useful for myriad purposes. Primarily, it allows Ubiquia developers to code
 * against representative API's without having to instantiate agents. Conceivably,
 * this feature can also allow devs to "harden" their API contracts as they'll undoubtedly
 * receive garbage data from this service.
 */
@Service
public class TemplateComponentProxy {

    private static final Logger logger = LoggerFactory.getLogger(TemplateComponentProxy.class);

    @Autowired
    private NodeRepository nodeRepository;

    private HashMap<String, Schema> cachedNodeSchemas;

    private DefaultConfig jsonSchemaGeneratorConfiguration;

    @Autowired
    private ObjectMapper objectMapper;
    @Autowired
    private Outbox outbox;
    @Autowired
    private StamperVisitor stamperVisitor;

    /**
     * Constructor time.
     */
    public TemplateComponentProxy() {
        this.cachedNodeSchemas = new HashMap<>();
        this.jsonSchemaGeneratorConfiguration = DefaultConfig.build()
            .setGenerateMinimal(false)
            .setNonRequiredPropertyChance(0.5f)
            .get();
    }

    /**
     * This method will act as a "proxy" for a real agent by generating fuzzy data
     * when an upstream event is sent. Put differently, this method allows an adapter to send
     * data to this service as if it were the actual agent.
     *
     * @param flowEventEntity The event generated by the agent's adapter.
     * @throws JsonProcessingException Exceptions from inability to process payloads.
     * @throws ClassNotFoundException  Exceptions from being unable to find a valid class.
     */
    @Transactional
    public void proxyAsComponentWith(FlowEventEntity flowEventEntity)
        throws JsonProcessingException,
        GenerationException,
        JsonGeneratorException {

        var eventTimes = flowEventEntity.getFlowEventTimes();
        eventTimes.setPayloadSentToComponentTime(OffsetDateTime.now());
        this.tryInitializeSchema(flowEventEntity.getNode().getId());
        var jsonSchema = this.cachedNodeSchemas.get(flowEventEntity.getNode().getId());
        var schemaStore = new SchemaStore(true);
        var generator = new Generator(
            this.jsonSchemaGeneratorConfiguration,
            schemaStore,
            new Random());
        var fuzzyData = generator.generate(jsonSchema, 10);
        var stringifiedPayload = this.objectMapper.writeValueAsString(fuzzyData);
        logger.debug("Generated dummy data: {}", stringifiedPayload);
        eventTimes.setComponentResponseTime(OffsetDateTime.now());
        this.stamperVisitor.tryStampOutputs(flowEventEntity, stringifiedPayload);
        if (flowEventEntity.getNode().getNodeSettings().getPersistOutputPayload()) {
            flowEventEntity.setOutputPayload(stringifiedPayload);
        }
        this.outbox.tryQueueMessage(flowEventEntity, stringifiedPayload);
    }

    /**
     * Attempt to initialize the JSON schema for the specific adapter.
     *
     * @param nodeId The id of the adapter to initialize a schema for.
     * @throws GenerationException Exception from generating dummy data.
     */
    private void tryInitializeSchema(final String nodeId) throws GenerationException {

        if (!this.cachedNodeSchemas.containsKey(nodeId)) {
            var record = this.nodeRepository.findById(nodeId);
            if (record.isEmpty()) {
                throw new RuntimeException("ERROR: Cannot find node with id: " + nodeId);
            }

            var entity = record.get();
            var jsonSchema = entity
                .getGraph()
                .getDomainOntology()
                .getDomainDataContract()
                .getJsonSchema();

            var schemaStore = new SchemaStore(true);
            var schema = schemaStore.loadSchemaJson(jsonSchema);

            var match = schema
                .getSubSchemas()
                .keySet()
                .stream()
                .filter(x -> x.toString().contains(entity.getOutputSubSchema().getModelName()))
                .findFirst();

            if (match.isEmpty()) {
                throw new RuntimeException("ERROR: Cannot find subschema named  '"
                    + entity.getOutputSubSchema().getModelName()
                    + "' in agent communication language named '"
                    + entity.getGraph().getDomainOntology().getName()
                    + "'!");
            }
            var jsonSubSchema = schema.getSubSchemas().get(match.get());
            this.cachedNodeSchemas.put(nodeId, jsonSubSchema);
        }
    }
}
