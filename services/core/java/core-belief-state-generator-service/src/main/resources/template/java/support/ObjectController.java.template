package org.ubiquia.acl.generated;

import io.minio.errors.MinioException;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.parameters.RequestBody; // OpenAPI, not Spring's
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import jakarta.transaction.Transactional;
import java.io.IOException;
import java.io.InputStream;
import java.sql.SQLException;
import java.util.Objects;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.bind.annotation.RequestPart;
import io.swagger.v3.oas.annotations.Parameter;
import org.ubiquia.common.library.api.interfaces.InterfaceEntityToDtoMapper;
import org.ubiquia.common.library.belief.state.libraries.service.io.MinioService;
import org.ubiquia.common.library.belief.state.libraries.service.io.ObjectMetadataService;
import org.ubiquia.common.library.dao.component.EntityDao;
import org.ubiquia.common.library.dao.controller.GenericUbiquiaDaoController;
import org.ubiquia.common.library.implementation.service.mapper.ObjectMetadataDtoMapper;
import org.ubiquia.common.model.ubiquia.dto.ObjectMetadata;
import org.ubiquia.common.model.ubiquia.entity.ObjectMetadataEntity;

@RestController
@RequestMapping("/ubiquia/belief-state-service/object")
@Transactional
public class ObjectController extends GenericUbiquiaDaoController<ObjectMetadataEntity, ObjectMetadata> {

    private static final Logger logger = LoggerFactory.getLogger(ObjectController.class);

    @Value("${ubiquia.beliefState.domainName}")
    private String domainName;

    @Autowired(required = false)
    private ObjectMetadataService objectMetadataService;

    @Autowired
    private ObjectMetadataDtoMapper dtoMapper;

    @Autowired
    private EntityDao<ObjectMetadataEntity> entityDao;

    @Autowired(required = false)
    private MinioService minioService;

    @Override
    public Logger getLogger() {
        return logger;
    }

    @Override
    public EntityDao<ObjectMetadataEntity> getDataAccessObject() {
        return this.entityDao;
    }

    @Override
    public InterfaceEntityToDtoMapper<ObjectMetadataEntity, ObjectMetadata> getDataTransferObjectMapper() {
        return this.dtoMapper;
    }

    @PostMapping(
        value = "/upload",
        consumes = MediaType.MULTIPART_FORM_DATA_VALUE
    )
    @Operation(
        summary = "Upload a file to object storage",
        description = "Select a file and upload it to the belief-state domain bucket.",
        requestBody = @RequestBody(
            required = true,
            content = @Content(
                mediaType = MediaType.MULTIPART_FORM_DATA_VALUE
                // No nested schema/properties needed for Swagger UI to render a file input
            )
        ),
        responses = {
            @ApiResponse(responseCode = "200", description = "Upload successful"),
            @ApiResponse(responseCode = "400", description = "Invalid request"),
            @ApiResponse(responseCode = "500", description = "Server error")
        }
    )
    public ObjectMetadata uploadFile(
        @Parameter(
            description = "File to upload",
            required = true,
            content = @Content(
                // Helps some versions render correctly, but not strictly required:
                mediaType = MediaType.APPLICATION_OCTET_STREAM_VALUE,
                schema = @Schema(type = "string", format = "binary")
            )
        )
        @RequestPart("file") MultipartFile file
    ) throws IOException, MinioException, SQLException {

        this.getLogger().info("Received a request to upload file {} to bucket {}...",
            file.getOriginalFilename(), this.domainName);

        if (Objects.isNull(this.minioService)) {
            throw new IllegalArgumentException("ERROR: No available object storage service is currently running...");
        }

        var metadata = this.objectMetadataService.persistObjectMetadata(this.domainName, file);
        this.minioService.uploadFile(this.domainName, metadata.getId(), file);
        this.getLogger().info("...object stored: {}", this.objectMapper.writeValueAsString(metadata));

        return metadata;
    }

    @GetMapping("/download/{filename}")
    public ResponseEntity<byte[]> downloadFile(
        @PathVariable("filename") String filename
    ) throws MinioException, IOException {

        this.getLogger().info("Received a request to download file {} from bucket {}...",
            filename, this.domainName);

        InputStream data = null;
        try {
            data = this.minioService.downloadFile(this.domainName, filename);
        } catch (MinioException e) {
            logger.info("MinioException: {}", e.getMessage());
        }

        if (Objects.isNull(data)) {
            this.getLogger().info("...no file found in that bucket...");
            return ResponseEntity.notFound().build();
        }

        this.getLogger().debug("...file found; retrieving...");
        return ResponseEntity
            .ok()
            .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + filename + "\"")
            .body(data.readAllBytes());
    }
}
