package org.ubiquia.common.library.belief.state.libraries.service.builder.entity;

import jakarta.transaction.Transactional;
import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.util.*;
import java.util.function.Supplier;
import org.apache.commons.lang3.reflect.FieldUtils;
import org.hibernate.Hibernate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.ubiquia.common.library.api.interfaces.InterfaceLogger;
import org.ubiquia.common.library.belief.state.libraries.service.finder.EntityRelationshipBuilderFinder;
import org.ubiquia.common.library.belief.state.libraries.service.finder.EntityRepositoryFinder;
import org.ubiquia.common.model.acl.entity.AbstractAclModelEntity;

/**
 * <p>An abstract class that enables generated belief states to persist model relationships
 * "a posteriori" to model definition (i.e., Agent Communication Language definition.)
 * In one sense, this code is largely concerned with ensuring updates to relational data propagate
 * through by crawling the entity's relationships.
 * </p>
 * <p>Consider this problem: what if a model is sent to Ubiquia for an update, but then Ubiquia
 * "saves" this model by persisting it in the database before "hydrating" any of the
 * relationships? If existing relationships aren't properly accounted for, this code could well
 * overwrite those relationships as "null" foreign keys. This code prevents this real, but tricky
 * scenario for entities generated by Ubiquia Belief States.
 * </p>
 * Fair warning: This code is gnarly because it solves gnarly problems.
 *
 * @param <T> The entity class to build relationships for.
 */
@Service
@Transactional
public abstract class EntityRelationshipBuilder<T extends AbstractAclModelEntity>
    implements InterfaceLogger {

    protected final Map<Field, Field> cachedEntityFieldMap = new HashMap<>();
    protected final Map<Field, Field> cachedEntityListFieldMap = new HashMap<>();
    protected final Map<Field, Field> cachedEntitySetFieldMap = new HashMap<>();
    protected final Class<T> cachedEntityClass;

    @Autowired
    private EntityRelationshipBuilderFinder entityRelationshipBuilderFinder;

    @Autowired
    private EntityRepositoryFinder repositoryFinder;

    /**
     * Constructor. Abandon all hope, ye who enter here.
     */
    @SuppressWarnings("unchecked")
    public EntityRelationshipBuilder() {
        this.getLogger().info("Caching reflection data...");
        this.cachedEntityClass = (Class<T>) ((ParameterizedType) this.getClass().getGenericSuperclass()).getActualTypeArguments()[0];
        var fields = FieldUtils.getAllFields(this.cachedEntityClass);

        for (var field : fields) {
            if (!this.tryCacheFieldRelationship(field)) {
                if (!this.tryCacheListFieldRelationship(field)) {
                    this.tryCacheSetFieldRelationship(field);
                }
            }
        }
        this.getLogger().info("...finished caching reflection data.");
    }

    /**
     * Provided an ACL entity, crawl through the model and hydrate any existing relationships
     * recursively.
     *
     * @param entity The entity we're building existing relationship data for.
     * @throws Exception Exceptions from black magic.
     */
    public void tryBuildRelationships(T entity) throws Exception {
        var entityName = getEntityClassName(entity);
        var builder = (EntityRelationshipBuilder<T>) this.tryGetRelationshipBuilderFor(entity);
        if (!this.cachedEntityClass.getName().equalsIgnoreCase(entityName)
            && Objects.nonNull(builder)) {
            builder.tryBuildRelationships(entity);
        } else {
            this.trySetRelationshipsFor(entity);
        }
    }

    /**
     * Provided an ACL entity, attempt to get the appropriate relationship builder.
     *
     * @param entity The entity to get a relationship builder for.
     * @return The appropriate relationship builder.
     */
    private EntityRelationshipBuilder<?> tryGetRelationshipBuilderFor(
        AbstractAclModelEntity entity) {

        var entityName = getEntityClassName(entity);
        EntityRelationshipBuilder<?> builder = null;
        if (!entityName.equalsIgnoreCase(this.cachedEntityClass.getSimpleName())) {
            builder = this.entityRelationshipBuilderFinder.findRelationshipBuilderFor(entity);
        }
        return builder;
    }

    /**
     * Provided an entity, ensure the existing relationships are properly "hydrated" by fetching
     * them from the database.
     *
     * @param entity The entity we're setting relationships for.
     * @throws Exception Exceptions from black magic.
     */
    @Transactional
    private void trySetRelationshipsFor(T entity) throws Exception {
        for (var key : this.cachedEntityFieldMap.keySet()) {
            this.handleBidirectionalRelationship(
                entity,
                key,
                key.get(entity),
                this.cachedEntityFieldMap.get(key));
        }

        for (var key : this.cachedEntityListFieldMap.keySet()) {
            var values = (List<?>) key.get(entity);
            key.set(entity, new ArrayList<>()); // reset to collect updated objects
            if (values != null) {
                for (var value : values) {
                    this.handleBidirectionalRelationship(
                        entity,
                        key,
                        value,
                        this.cachedEntityListFieldMap.get(key));
                }
            }
        }

        for (var key : this.cachedEntitySetFieldMap.keySet()) {
            var values = (Set<?>) key.get(entity);
            key.set(entity, new HashSet<>());
            if (values != null) {
                for (var value : values) {
                    handleBidirectionalRelationship(
                        entity,
                        key,
                        value,
                        this.cachedEntitySetFieldMap.get(key));
                }
            }
        }
    }

    /**
     * Ensure that both parent and child entity "point" to each other by referencing each other.
     *
     * @param parent            The parent entity.
     * @param parentField       The field of the parent referencing the child.
     * @param child             The child entity.
     * @param childBackRefField The field of the child referencing the parent.
     * @throws Exception Black magic exceptions.
     */
    private void handleBidirectionalRelationship(
        T parent,
        Field parentField,
        Object child,
        Field childBackRefField)
        throws Exception {

        if (Objects.nonNull(child)) {

            var unproxiedChild = Hibernate.unproxy(child);

            this.getLogger().debug("...handling bidirectional child entity: {} ",
                unproxiedChild.getClass().getSimpleName());

            var repository = this.repositoryFinder.findRepositoryFor(unproxiedChild);
            var idRecord = this.getIdValueFor(unproxiedChild);

            Object persistedChild = null;
            if (idRecord.isPresent()) {
                Object fetched = null;
                try {
                    fetched = repository.findById(idRecord.get()).orElseThrow(()
                        -> new IllegalArgumentException("No entity with ID: " + idRecord.get()));
                } catch (Throwable e) {
                    throw new RuntimeException(e);
                }
                this.linkParentToChild(fetched, parent, childBackRefField);
                persistedChild = repository.save(fetched);
            } else {
                this.tryBuildNestedRelationshipsIfNeededFor(unproxiedChild);
                this.linkParentToChild(unproxiedChild, parent, childBackRefField);
                persistedChild = repository.save(unproxiedChild);
            }

            updateParentFieldWithChild(parent, parentField, persistedChild);
        }
    }

    /**
     * Ensure that the parent object points to the child object by accounting for collection
     * as well as singleton references.
     *
     * @param child             The child entity to manage.
     * @param parent            The parent entity to manage.
     * @param childBackRefField The field referencing the parent in the child.
     * @throws Exception Black magic exception.
     */
    private void linkParentToChild(
        Object child,
        Object parent,
        Field childBackRefField)
        throws Exception {

        if (List.class.isAssignableFrom(childBackRefField.getType())) {
            var list = this.ensureCollectionInitialized(
                childBackRefField,
                child,
                ArrayList::new);
            list.add(parent);
        } else if (Set.class.isAssignableFrom(childBackRefField.getType())) {
            var set = this.ensureCollectionInitialized(
                childBackRefField,
                child,
                HashSet::new);
            set.add(parent);
        } else {
            childBackRefField.set(child, parent);
        }
    }

    /**
     * Update a parent entity with the child entity.
     *
     * @param parent      The parent entity to update.
     * @param parentField The field of the parent referencing the child.
     * @param child       The child entity.
     * @throws Exception Black magic exceptions.
     */
    private void updateParentFieldWithChild(
        Object parent,
        Field parentField,
        Object child)
        throws Exception {

        if (List.class.isAssignableFrom(parentField.getType())) {
            var list = this.ensureCollectionInitialized(
                parentField,
                parent,
                ArrayList::new);
            list.add(child);
        } else if (Set.class.isAssignableFrom(parentField.getType())) {
            var set = this.ensureCollectionInitialized(
                parentField,
                parent,
                HashSet::new);
            set.add(child);
        } else {
            parentField.set(parent, child);
        }
    }

    /**
     * Attempt to recursively build nested relationships as needed.
     *
     * @param child The child to update.
     * @throws Exception Exceptions from black magic.
     */
    private void tryBuildNestedRelationshipsIfNeededFor(Object child) throws Exception {
        if ((child instanceof AbstractAclModelEntity entity)) {
            var entityName = this.getEntityClassName(entity);
            if (!entityName.equalsIgnoreCase(this.cachedEntityClass.getSimpleName())) {
                var builder =
                    (EntityRelationshipBuilder<T>) this.tryGetRelationshipBuilderFor(entity);
                if (Objects.nonNull(builder)) {
                    builder.tryBuildRelationships((T) entity);
                }
            }
        }
    }

    /**
     * Given an entity, try to retrieve the ID value from it.
     *
     * @param entity The entity to retrieve a value from.
     * @return An optional representing the ID value.
     */
    private Optional<Object> getIdValueFor(Object entity) {
        var fields = FieldUtils.getAllFields(entity.getClass());
        var fieldsList = Arrays.stream(fields).toList();
        var id = fieldsList
            .stream()
            .filter(x -> x.getName().equals("id"))
            .findFirst()
            .map(x -> {
                x.setAccessible(true);
                try {
                    return x.get(entity);
                } catch (IllegalAccessException e) {
                    throw new RuntimeException("Unable to access ID field: " + e);
                }
            });
        return id;
    }

    /**
     * Because every dense Java library needs collections and factories.
     *
     * @param field   The field to ensure is initialized.
     * @param entity  The entity with the field.
     * @param factory The factory that's "factory-ing" our collection.
     * @return A new collection.
     * @throws IllegalAccessException Reflection exceptions.
     */
    @SuppressWarnings("unchecked")
    private Collection<Object> ensureCollectionInitialized(
        Field field,
        Object entity,
        Supplier<? extends Collection<Object>> factory)
        throws IllegalAccessException {

        field.setAccessible(true);
        Collection<Object> collection = (Collection<Object>) field.get(entity);
        if (Objects.isNull(collection)) {
            collection = factory.get();
            field.set(entity, collection);
        }
        return collection;
    }

    /**
     * Attempt to cache a relationship for a field so we don't always have to eat
     * lookup costs at runtime.
     *
     * @param field The field to cache.
     * @return Whether or not we cached it.
     */
    private Boolean tryCacheFieldRelationship(Field field) {
        var cached = false;
        if (AbstractAclModelEntity.class.isAssignableFrom(field.getType())) {
            cached = this.tryCacheEntityRelationship(field);
        }
        return cached;
    }

    /**
     * Attempt to cache a relationship for a field so we don't always have to eat
     * lookup costs at runtime.
     *
     * @param field The field to cache.
     * @return Whether or not we cached it.
     */
    private boolean tryCacheEntityRelationship(Field field) {
        var cached = false;

        var subFields = Arrays.asList(FieldUtils.getAllFields(field.getType()));

        var directRef = subFields.stream().filter(f -> f
                .getType()
                .isAssignableFrom(this.cachedEntityClass))
            .findFirst();

        if (directRef.isPresent()) {
            field.setAccessible(true);
            directRef.get().setAccessible(true);
            this.cachedEntityFieldMap.put(field, directRef.get());
            cached = true;
        }

        var listField = subFields.stream().filter(f -> List.class.isAssignableFrom(f.getType()))
            .findFirst();

        if (listField.isPresent()) {
            var paramType = (ParameterizedType) listField.get().getGenericType();
            var elementClass = (Class<?>) paramType.getActualTypeArguments()[0];
            if (elementClass.isAssignableFrom(this.cachedEntityClass)) {
                field.setAccessible(true);
                this.cachedEntityFieldMap.put(field, listField.get());
                cached = true;
            }
        }
        return cached;
    }

    /**
     * Helper to cache a specific kind of relationship.
     *
     * @param field The field to cache away.
     * @return Whether we cached successfully or not.
     */
    private Boolean tryCacheListFieldRelationship(Field field) {
        return tryCacheCollectionField(field, List.class, this.cachedEntityListFieldMap);
    }

    /**
     * Helper to cache a specific kind of relationship.
     *
     * @param field The field to cache away.
     * @return Whether we cached successfully or not.
     */
    private Boolean tryCacheSetFieldRelationship(Field field) {
        return tryCacheCollectionField(field, Set.class, this.cachedEntitySetFieldMap);
    }

    /**
     * Helper to cache a specific kind of relationship.
     *
     * @param field           The field to cache.
     * @param collectionClass The class of the elements of a collection.
     * @param cache           The cache to set.
     * @return Whether we cached successfully or not.
     */
    private Boolean tryCacheCollectionField(
        Field field,
        Class<?> collectionClass,
        Map<Field, Field> cache) {

        var cached = false;

        if ((field.getGenericType() instanceof ParameterizedType parameterizedType)) {
            var elementClass = (Class<?>) parameterizedType.getActualTypeArguments()[0];

            var subFields = Arrays.asList(FieldUtils.getAllFields(elementClass));
            var backRef = subFields.stream().filter(f -> f.getType().isAssignableFrom(cachedEntityClass)).findFirst();
            if (backRef.isPresent()) {
                field.setAccessible(true);
                backRef.get().setAccessible(true);
                cache.put(field, backRef.get());
                cached = true;
            }

            var sameCollectionFields = subFields.stream().filter(f -> collectionClass.isAssignableFrom(f.getType()));
            for (var f : sameCollectionFields.toList()) {
                var childElementType = (ParameterizedType) f.getGenericType();
                var childClass = (Class<?>) childElementType.getActualTypeArguments()[0];
                if (childClass.isAssignableFrom(cachedEntityClass)) {
                    field.setAccessible(true);
                    cache.put(field, f);
                    cached = true;
                }
            }
        }

        return cached;
    }

    /**
     * Provided an ACL entity, build and return the class name.
     *
     * @param entity The entity we're building a name for.
     * @return The entity class name.
     */
    private String getEntityClassName(final AbstractAclModelEntity entity) {
        return entity.getModelType() + "Entity";
    }
}
